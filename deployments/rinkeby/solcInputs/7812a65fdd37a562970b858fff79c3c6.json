{
    "language": "Solidity",
    "sources": {
        "contracts/FundMe.sol": {
            "content": "// Get funds from users & withdraw funds\n// Set a minimum deposit in USD\n\n/*\n\nDecentralized Oracles:\n\n- blockchains are deterministic so that nodes can reach consensus.\n- randomness would mean you cant reach a consensus\n- so how do you get random data and/or api calls?\n- oracles.\n- but if u get that oracle data from a centralized node, whats the point of the smart contract?\n- chainlink brings decentralized oracle data from offchain to on chain.\n\nChainlink data feeds:\n- network of nodes gets data from apis/data providers etc.\n- the nodes then come ot a consensus and deliver to a contract, which can be called.\n\nChainlink VRF:\n- get verifiably random numbers delivered to your smart contract\n\nChainlink keepers:\n- decentralized event driven computation. if trigger then do this\n\nChainlink APIs:\n- can grab data from anywhere in the world via api. We will learn more about this...\n\nGAS OPTIMIZATIONS\n\n+ constant keyword.\n- say you assign a variable at compile and never change it. E.g. minimumUsd in our contract. You can give it the constant keyword and it will take up less storage space.\n- constant variable naming convention is ALL CAPS\n\n+ immutable keyword.\n- say you assign a variable at compile but don't set it. you only set it once, later in the contract.\n- e.g., \"owner\" variable in our contract, which is declared at compile and assigned in the constructor.\n- use immutable.\n- convention is setting the variable as \"i_varName\"\n\n+ custom errors (solidity 0.8.4+)\n- declare an error outside of the contract.\n- see onlyOwner modifier below for details.\n\n*/\n\npragma solidity ^0.8.4;\n\nimport \"./PriceConverter.sol\";\n\nerror NotOwner();\n\ncontract FundMe {\n    // if you use a library for some functions (which we are doing with PriceConverter.sol), you can \"attach\" those functions to specific types.\n    // then it sort of acts like a method of a class object in python where you can do .function on a variable of that type.\n    // the keyword is \"using <LIBRARY> for <TYPE>\"\n    // e.g. we're using PriceConverter with the line here: require(msg.value.getConversionRate() >= MINIMUMUSD);\n    using PriceConverter for uint256;\n\n    uint256 public number;\n    uint256 public constant MINIMUMUSD = 50 * 1e18;\n\n    // HARDHAT VERSION ADDITIONS:\n    AggregatorV3Interface public priceFeed;\n\n    // Transaction fields:\n    // - Every tx will have the following fields:\n    // 1) Nonce 2) Gas Price 3) Gas Limit 4) To 5) Value 6) Data 7) v, r, s (components of tx signature).\n    // Notice that every tx can have a value in wei. It can also have other value (not in wei) included in data.\n\n    address[] public funders;\n    mapping(address => uint256) public addressToAmountFunded;\n\n    address public immutable i_owner;\n\n    // gets called upon deployment.\n    // we can set the declared \"owner\" variable to be equal to the address of whoever deployed the contract initially.\n\n    // original/remix version constructor didnt take any parameters.\n    // constructor() {\n    //     i_owner = msg.sender;\n    // }\n\n    // HARDHAT VERSION OF CONSTRUCTOR - for chainlink price feed address to be modular\n    constructor(address priceFeedAddress) {\n        i_owner = msg.sender;\n        priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    // error checking. say you forgot the \"payable\" below...\n    // Step 1. read error code and it might be straightforward (e.g. in this case it will say make it payable)\n    // -- spend at least 15-20 minutes on step 1 before trying next steps\n    // Step 2. say you tinkered and can't figure it out. Google the error.\n    // Step 2.5. for this course only, go to the github repo for this course.\n    // Step 3. Ask a question on a forum like stack exchange eth and stack overflow.\n    //\n\n    function fund() public payable {\n        // PAYABLE keyword is key. Allows someone to send wei with this function.\n        // Just like the wallet can hold funds, so too can a contract address.\n\n        // set a minimum fund amount in USD\n        // -- remember, every tx will include the field 'value' so msg.value is just allowing us to grab that amount (could be 0 in a lot of cases).\n        // -- require will revert if a condition is not met.s\n\n        number = 5;\n        // require(msg.value >= 1e18); // 1e18 wei == 1 eth\n        // require(msg.value >= minimumUsd);\n\n        // BEFORE using a library we would've done this:\n        // require(getConversionRate(msg.value) >= minimumUsd, \"didn't send enough!\");\n\n        // NOW with using a library we do this:\n        // note that the variable that this function is being applied to will serve as the first input into that function\n        // // REMIX VERSION:\n        // // require(msg.value.getConversionRate() >= MINIMUMUSD);\n\n        // // NEW VERSION FOR HARDHAT. We pass the newly created modular priceFeed object in as second variable (first variable is msg.value).\n        require(msg.value.getConversionRate(priceFeed) >= MINIMUMUSD);\n\n        // revert:\n        // -- undo any actions from before and send any leftover gas back.\n        // -- e.g. in above, number will no longer be stored as 5 if you sent less than 1 eth.\n\n        // msg.sender = address of sender\n        funders.push(msg.sender);\n        addressToAmountFunded[msg.sender] = msg.value;\n    }\n\n    function withdraw() public onlyOwner {\n        // we are going to use a modifier instead of code below, but this would be another way to make sure the owner is only one calling this.\n        // make sure that the sender is the owner of the contract i.e. the person who deployed it.\n        // require(msg.sender == owner, \"sender is not owner\");\n\n        // for loop\n        // for (starting index, ending index, step amount)\n        // option 1: loop thru and reset each variable in the array\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < funders.length;\n            funderIndex++\n        ) {\n            address funder = funders[funderIndex];\n            addressToAmountFunded[funder] = 0;\n        }\n\n        // option 2: reset the array\n        funders = new address[](0); // 0 specifies how many elements are in the array to start\n\n        // now need to withdraw the funds\n        // three ways: transfer, send, call\n\n        // // transfer\n        // // msg.sender (type address) needs to be typecast to payable msg.sender\n        // payable(msg.sender).transfer(address(this).balance);\n\n        // issues with transfer: if it fails, it will not return a boolean it will just fail\n        // can use .send which will reeturn a boolean.\n\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        // require(sendSuccess, \"Send failed\");\n\n        // call doesnt have capped gas.\n        // call is RECOMMENDED WAY TO SEND/RECEIVE.\n        // (bool callSuccess, bytes dataReturned) = payable(msg.sender).call{value: address(this).balance}(\"\")\n        (bool callSuccess, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != i_owner) {\n            revert NotOwner();\n        }\n        // require(msg.sender == i_owner, \"Sender is not owner!\");\n        _; // this represents DO THE REST OF CODE in the function that uses this modifier.\n    }\n\n    // what happens if someone sends this contract eth without calling the fund contract?\n\n    // receive & fallback are special functions in solidity.\n    // see FallbackExample.sol\n\n    // one purpose of this is if someone accidentally calls the wrong function but still sends eth, this will still work as if they had called fund()\n\n    receive() external payable {\n        fund();\n    }\n\n    fallback() external payable {\n        fund();\n    }\n}\n"
        },
        "contracts/PriceConverter.sol": {
            "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// import \"./AggregatorV3Interface.sol\";\n\n// REMIX knows how to automatically download below using npm.\n// With local code we need to add these manually\n// it is much simpler than with brownie. Just do yarn add --dev @chainlink/contracts and then you dont have to touch the code below. Hardfhat will find it in node_modules folder\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// librarys cant maintain state and also cant send ether\n// all of the functions are internal.\n\nlibrary PriceConverter {\n    // since we want to compare a value to a USD-based minimum, we need to get the price of eth in USD first.\n    // ORIGINAL REMIX VERSION DIDNT INCLUDE AggregatorV3Interface as FUNCTION IN getPrice()\n    function getPrice(AggregatorV3Interface priceFeed)\n        internal\n        view\n        returns (uint256)\n    {\n        // THE BELOW CODE WAS WITH REMIX VERSION. NOW THAT WE PASS IN AN INTERFACE, NO LONGER NEED TO CREATE IT HERE.\n        // // We're interacting with another contract so we need:\n        // // 1) Address... we can get from docs: 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e (Rinkeby)\n        // // 2) ABI... we can use an interface.\n        // // --- interfaces DECLARE the functions but doesnt say what they do. That's fine because we just need the names / required inputs / required outputs of the functions.\n        // AggregatorV3Interface priceFeed = AggregatorV3Interface(\n        //     0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n        // );\n        // // (uint80 roundID, int price, uint startedAt, uint timeStamp, uint80 answeredInRound) = priceFeed.latestRoundData();\n        (, int256 price, , , ) = priceFeed.latestRoundData(); // int instead of uint so that it can be negative.\n        return uint256(price * 1e10); // because the chainlink oracle data is 8 decimals versus wei is 18\n    }\n\n    // function getVersion() internal view returns (uint256) {\n    //     AggregatorV3Interface priceFeed = AggregatorV3Interface(\n    //         0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n    //     );\n    //     return priceFeed.version();\n    // }\n\n    // Original REMIX VERSION\n    // function getConversionRate(uint256 ethAmount)\n    // HARDHAT VERSION (incorporates modular priceFeed)\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        // ORIGINAL REMIX VERSION DIDNT INCLUDE priceFeed AS A VARIABLE IN getPrice()\n        uint256 ethPrice = getPrice(priceFeed);\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\n        return ethAmountInUsd;\n    }\n}\n"
        },
        "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
        }
    },
    "settings": {
        "optimizer": {
            "enabled": false,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata",
                    "devdoc",
                    "userdoc",
                    "storageLayout",
                    "evm.gasEstimates"
                ],
                "": ["ast"]
            }
        },
        "metadata": {
            "useLiteralContent": true
        }
    }
}
